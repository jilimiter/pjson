# -*- coding: utf-8 -*-
"""PSJON.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DgIyCqGeurxwfIONOBZ7a2uPXxUnosNw
"""

!pip install fastf1

import fastf1
import pandas as pd
import os

# 1. 캐시 폴더 설정
# Colab의 임시 폴더를 캐시로 사용합니다.
if not os.path.exists('cache'):
    os.makedirs('cache')
fastf1.Cache.enable_cache('cache')

print("데이터를 불러오는 중입니다... ")

# 2. 세션 로드 (2025년 일본 GP, 레이스)
# 'R'은 Race, 'Q'는 Qualifying
session = fastf1.get_session(2025, 'Japan', 'R')
session.load()

# 3. 드라이버 선택 (Max Verstappen -> 'VER')
driver = 'VER'
driver_laps = session.laps.pick_driver(driver)

print(f"{driver} 선수의 데이터를 처리 중입니다...")

# --- 데이터셋 1: 랩(Lap) 데이터 ---
# 랩 타임, 섹터 타임, 타이어 컴파운드 등
driver_laps.to_csv(f'{session.event.year}_Japan_{driver}_laps.csv', index=False)
print("1. 랩 데이터 저장 완료.")

# --- 데이터셋 2: 가장 빠른 랩의 텔레메트리 ---
# 스피드, RPM, 기어, 스로틀, 브레이크 등
fastest_lap = driver_laps.pick_fastest()
telemetry = fastest_lap.get_telemetry()
telemetry.to_csv(f'{session.event.year}_Japan_{driver}_fastest_telemetry.csv', index=False)
print("2. 패스티스트 랩 텔레메트리 저장 완료.")

# --- 데이터셋 3: 전체 레이스 텔레메트리 ---
# 주의: 데이터가 크고 처리 시간이 걸립니다. 필요 없다면 주석 처리하세요.
# 전체 랩의 텔레메트리를 하나로 합칩니다.
print("3. 전체 레이스 텔레메트리 추출 중... ")
all_telemetry_list = []

# 각 랩을 순회하며 텔레메트리 추출
for i, lap in driver_laps.iterlaps():
    # 텔레메트리 가져오기
    tel = lap.get_telemetry()
    # 어떤 랩인지 구분하기 위해 LapNumber 컬럼 추가
    tel['LapNumber'] = lap['LapNumber']
    all_telemetry_list.append(tel)

# 하나로 합치기
full_telemetry = pd.concat(all_telemetry_list)
full_telemetry.to_csv(f'{session.event.year}_Japan_{driver}_full_telemetry.csv', index=False)
print("3. 전체 레이스 텔레메트리 저장 완료.")

print("\n=== 모든 작업 완료\===")

import fastf1
import pandas as pd
import os
import zipfile

# 1. 캐시 폴더 설정
if not os.path.exists('cache'):
    os.makedirs('cache')
fastf1.Cache.enable_cache('cache')

# --- 설정 변수 ---
target_years = [2023, 2024, 2025]  # 추출할 연도 리스트
driver = 'VER'                     # 드라이버: 막스 베르스타펜
circuit = 'Japan'                  # 서킷: 일본 (스즈카)
session_type = 'R'                 # 세션: Race (예선은 'Q')

print(f"[{driver}] 선수의 {target_years}년도 {circuit} GP 데이터를 추출합니다.\n")

generated_files = [] # 생성된 파일명을 저장할 리스트

for year in target_years:
    print(f"==================================================")
    print(f"Processing: {year}년 {circuit} Grand Prix...")

    try:
        # 세션 로드
        session = fastf1.get_session(year, circuit, session_type)
        session.load()

        # 드라이버 선택
        driver_laps = session.laps.pick_driver(driver)

        # 1) 랩 데이터 저장 (Laps)
        filename_laps = f'{year}_{circuit}_{driver}_laps.csv'
        driver_laps.to_csv(filename_laps, index=False)
        generated_files.append(filename_laps)
        print(f"  -> [저장완료] {filename_laps}")

        # 2) 패스티스트 랩 텔레메트리 (Fastest Lap Telemetry)
        fastest_lap = driver_laps.pick_fastest()
        telemetry = fastest_lap.get_telemetry()
        filename_fastest = f'{year}_{circuit}_{driver}_fastest_telemetry.csv'
        telemetry.to_csv(filename_fastest, index=False)
        generated_files.append(filename_fastest)
        print(f"  -> [저장완료] {filename_fastest}")

        # 3) 전체 레이스 텔레메트리 (Full Telemetry) - 데이터가 큼
        print(f"  -> 전체 텔레메트리 추출 중... (시간 소요됨)")
        all_telemetry_list = []
        for i, lap in driver_laps.iterlaps():
            tel = lap.get_telemetry()
            tel['LapNumber'] = lap['LapNumber']
            all_telemetry_list.append(tel)

        full_telemetry = pd.concat(all_telemetry_list)
        filename_full = f'{year}_{circuit}_{driver}_full_telemetry.csv'
        full_telemetry.to_csv(filename_full, index=False)
        generated_files.append(filename_full)
        print(f"  -> [저장완료] {filename_full}")

    except Exception as e:
        print(f"  !! 에러 발생 ({year}년): {e}")

print(f"\n==================================================")
print("모든 데이터 추출이 완료되었습니다.")

# --- 압축 파일 생성 ---
zip_filename = f"{driver}_{circuit}_Data_{target_years[0]}-{target_years[-1]}.zip"
print(f"파일을 '{zip_filename}'으로 압축 중입니다...")

with zipfile.ZipFile(zip_filename, 'w') as zipf:
    for file in generated_files:
        if os.path.exists(file):
            zipf.write(file)

print(f"압축 완료! 왼쪽 파일 탐색기에서 '{zip_filename}' 하나만 다운로드하세요.")

import pandas as pd
import matplotlib.pyplot as plt
import ipywidgets as widgets
from IPython.display import display, clear_output
import io

# F1 및 일반 로그 데이터용 단위 매핑 사전
UNIT_MAP = {
    'Speed': 'km/h',
    'RPM': 'RPM',
    'Throttle': '%',
    'Brake': '% (or Toggle)',
    'nGear': 'Gear',
    'Distance': 'm',
    'Time': 'sec',
    'X': 'm', 'Y': 'm', 'Z': 'm',
    'RelativeDistance': 'Ratio (0-1)'
}

# UI 구성
upload_button = widgets.FileUpload(accept='.csv', multiple=False, description="CSV 업로드")
x_axis_dropdown = widgets.Dropdown(options=['Index'], description='X축 선택:', value='Index')
vars_select = widgets.SelectMultiple(options=[], description='변수 선택:', rows=8)
start_button = widgets.Button(description="그래프 그리기", button_style='success', icon='check')
output = widgets.Output()

def load_columns(change):
    """파일이 업로드되면 변수 목록을 업데이트합니다."""
    if not upload_button.value: return

    uploaded_file = list(upload_button.value.values())[0]
    df_temp = pd.read_csv(io.BytesIO(uploaded_file['content']), nrows=5)

    # 숫자형 컬럼 추출
    numeric_cols = df_temp.select_dtypes(include=['number']).columns.tolist()

    # 시간 관련 컬럼이 있다면 추가 (timedelta 변환용)
    potential_x = [col for col in df_temp.columns if 'Time' in col or 'Distance' in col] + ['Index']

    x_axis_dropdown.options = potential_x
    vars_select.options = numeric_cols
    vars_select.value = [c for c in ['Speed', 'RPM', 'Throttle', 'nGear'] if c in numeric_cols]

upload_button.observe(load_columns, names='value')

def plot_data(b):
    with output:
        clear_output()
        if not upload_button.value:
            print("CSV 파일을 먼저 업로드해주세요.")
            return

        uploaded_file = list(upload_button.value.values())[0]
        df = pd.read_csv(io.BytesIO(uploaded_file['content']))

        selected_vars = vars_select.value
        x_col = x_axis_dropdown.value

        if not selected_vars:
            print("시각화할 변수를 선택해주세요.")
            return

        # X축 데이터 처리
        if x_col == 'Index':
            x_data = df.index
            x_label = "Data Index"
        elif 'Time' in x_col:
            # 시간 문자열을 초(seconds) 단위로 변환 시도
            try:
                x_data = pd.to_timedelta(df[x_col]).dt.total_seconds()
                x_label = f"{x_col} (Seconds)"
            except:
                x_data = df[x_col]
                x_label = x_col
        else:
            x_data = df[x_col]
            x_label = f"{x_col} ({UNIT_MAP.get(x_col, 'unit')})"

        # 그래프 그리기
        num_vars = len(selected_vars)
        fig, axes = plt.subplots(nrows=num_vars, ncols=1, figsize=(12, 3 * num_vars), sharex=True)

        if num_vars == 1: axes = [axes]

        for i, col in enumerate(selected_vars):
            axes[i].plot(x_data, df[col], color='C'+str(i % 10), linewidth=1.5)

            # Y축 단위 매핑
            unit = UNIT_MAP.get(col, '')
            title_text = f"{col} ({unit})" if unit else col

            axes[i].set_ylabel(title_text, fontsize=10, fontweight='bold')
            axes[i].grid(True, linestyle=':', alpha=0.6)
            axes[i].spines['top'].set_visible(False)
            axes[i].spines['right'].set_visible(False)

        plt.xlabel(x_label, fontsize=12)
        plt.tight_layout()
        plt.show()

start_button.on_click(plot_data)

# 레이아웃 표시
display(widgets.VBox([
    widgets.HBox([upload_button, x_axis_dropdown]),
    vars_select,
    start_button
]), output)